"""
lab.py: module that serve homelab management using Incus containers
"""
import json
import getpass
import os
from pathlib import Path
import subprocess
from datetime import datetime
import yaml
from .config import LabConfig
from .utils import container_exists, run, info, success, error, warning

class Lab:
    """
    Lab: class that encapsulates both data and mechanism for managing homelabs
    """
    def __init__(self, root: Path):
        self.root = root.absolute()
        self.config_path = self.root / "lab.yaml"
        self.config = LabConfig(self.config_path).load()
        self.nodes_dir = self.root / "nodes"
        self.shared_dir = self.root / "shared"
        self.dry_run = False

    def _describe_and_apply(self, actions, dry_run=False):
        """
        _describe_and_apply: show all planned actions, then execute if not dry_run.
        """
        if not actions:
            info("Nothing to do.")
            return

        info("Planned actions:")
        for act in actions:
            print(f"  {act['desc']}")

        if dry_run:
            info("DRY RUN: No changes applied")
            return

        # Apply
        for act in actions:
            try:
                act['func'](*act.get('args', ''), **act.get('kwargs', {}))
            except Exception as e:
                error(f"Failed to execute: {act['desc']} → {e}")
                raise

        success("All actions completed")

    def _log_event(self, action: str, **details):
        """
        _log_event: logs event triggered by homelab management ops
        """
        log_dir = self.root / "logs"
        log_dir.mkdir(exist_ok=True)
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        log_file = log_dir / f"{timestamp}-{action}.txt"

        data = {
            "action": action,
            "user": getpass.getuser(),
            "timestamp": timestamp,
            "lab": self.config["name"],
            **details
        }

        lines = [f"{k.upper()}: {v}" for k, v in data.items()]
        log_file.write_text("\n".join(lines) + "\n")

    @classmethod
    def init(cls, path: Path):
        """
        init: initialize a new lab from inside the target directory
        """
        path.mkdir(exist_ok=True)
        lab = cls(path)
        lab.nodes_dir.mkdir(exist_ok=True)
        lab.shared_dir.mkdir(exist_ok=True)

        # Create git repo
        if not (path / ".git").exists():
            subprocess.run(["git", "init"], cwd=path, text=True, check=True)
            subprocess.run(["git", "add", "."], cwd=path, text=True, check=True)
            subprocess.run(["git", "commit", "-m", "labkit: initial commit"],
                           cwd=path, input="init", text=True, check=True)

        # Create README
        readme = path / "README.md"
        if not readme.exists():
            readme.write_text(f"# {lab.config['name']}\n\nGenerated by labkit.\n")

        success(f"Lab initialized at {path}")
        info("Next: labkit node add <name>")
        return lab

    def add_requirement(self, node_names, dry_run=False):
        """
        add_requirement: adds external node as requirement without including
        the node into the lab
        """
        lab_name = self.config["name"]
        requires = set(self.config.get("requires_nodes", []))

        actions = []
        needs_save = False  # ← Track if we need to save lab.yaml

        for name in node_names:
            if not container_exists(name):
                warning(f"Container '{name}' does not exist")
                continue

            if name not in requires:
                requires.add(name)
                needs_save = True  # ← Mark for save later

                def update_required_by(container_name):
                    result = run(
                        ["incus", "config", "get", container_name, "user.required_by"],
                        silent=True, check=False
                    )
                    current = set()
                    if result.returncode == 0 and result.stdout.strip():
                        current = set(result.stdout.strip().split(","))
                    if lab_name not in current:
                        current.add(lab_name)
                        new_val = ",".join(sorted(current))
                        run([
                            "incus", "config", "set", container_name,
                            f"user.required_by={new_val}"
                        ], check=True)

                actions.append({
                    "desc": f"Add '{lab_name}' to {name}.user.required_by",
                    "func": update_required_by,
                    "args": (name,)
                })

        # Save config if any new requirements were added
        if needs_save:
            def save_lab_config():
                self.config["requires_nodes"] = sorted(requires)
                self.save_config()

            actions.append({
                "desc": "Save updated lab.yaml",
                "func": save_lab_config,
            })

        self._describe_and_apply(actions, dry_run)

    def remove_requirement(self, node_names, dry_run=False):
        """
        remove_requirement: removes included external node from requirement
        """
        lab_name = self.config["name"]
        requires = set(self.config.get("requires_nodes", []))
        original_count = len(requires)

        actions = []
        needs_save = False  # ← Will set to True if we remove anything

        for name in node_names:
            if name in requires:
                requires.discard(name)
                needs_save = True  # ← Mark for save

                def update_on_node(container_name):
                    result = run(
                        ["incus", "config", "get", container_name, "user.required_by"],
                        silent=True, check=False
                    )
                    if result.returncode != 0:
                        return
                    current = set(result.stdout.strip().split(",")) \
                        if result.stdout.strip() else set()
                    if lab_name in current:
                        current.remove(lab_name)
                        if current:
                            new_val = ",".join(sorted(current))
                            run([
                                "incus", "config", "set", container_name,
                                f"user.required_by={new_val}"
                            ], check=True)
                        else:
                            run(["incus", "config", "unset", container_name, "user.required_by"],
                                check=True)

                actions.append({
                    "desc": f"Remove '{lab_name}' from {name}.user.required_by",
                    "func": update_on_node,
                    "args": (name,)
                })

        # Save config only if we removed something
        if needs_save and len(requires) != original_count:
            def save_lab_config():
                self.config["requires_nodes"] = sorted(requires)
                self.save_config()

            actions.append({
                "desc": "Save updated lab.yaml",
                "func": save_lab_config
            })

        self._describe_and_apply(actions, dry_run)

    def up(self, only=None, include_deps=True, dry_run=False):
        """
        up: bring up the lab, starting Incus containers
        """
        # Parse --only into list
        target_nodes = []
        if only:
            target_nodes = [n.strip() for n in only.split(",") if n.strip()]
            info(f"Target nodes: {', '.join(target_nodes)}")

        # Get current container states
        result = run(["incus", "list", "--format=json"], silent=True)
        containers = json.loads(result.stdout)
        running_names = {c["name"] for c in containers if c["status"] == "Running"}

        # Determine which local nodes to start
        local_node_dirs = [d.name for d in self.nodes_dir.iterdir() if d.is_dir()]
        local_to_start = []

        if only:
            for name in target_nodes:
                target_name = f"{self.config['name']}-{name}"
                if name not in local_node_dirs:
                    warning(f"Node '{name}' not found in nodes/ — skipping")
                elif target_name not in running_names:
                    local_to_start.append(name)
        else:
            # Start all local nodes that aren't running
            local_to_start = [f"{self.config['name']}-{n}" for n in local_node_dirs
                              if f"{self.config['name']}-{n}" not in running_names]

        # Determine required nodes to start
        required_to_start = []
        if include_deps:
            required_nodes = self.config.get("requires_nodes", [])
            required_to_start = [n for n in required_nodes if n not in running_names]

        # Build actions
        actions = []

        # Start required nodes first
        for name in required_to_start:
            actions.append({
                "desc": f"Start required node: {name}",
                "func": run,
                "args": (["incus", "start", name],),
                "kwargs": {"check": True}
            })

        # Start local nodes
        for name in local_to_start:
            actions.append({
                "desc": f"Start local node: {name}",
                "func": run,
                "args": (["incus", "start", f"{self.config['name']}-{name}"],),
                "kwargs": {"check": True}
            })

        # Log event
        def log_up():
            self._log_event(
                "up",
                nodes_started=local_to_start,
                requires_started=required_to_start,
                filtered=only
            )

        if actions:
            actions.append({
                "desc": "Log up event",
                "func": log_up
            })

        self._describe_and_apply(actions, dry_run)

    def _process_only_flag(self, target, local_nodes, running_nodes, to_stop):
        if target:
            target_nodes = [n.strip() for n in target.split(",") if n.strip()]
            info(f"Target nodes: {', '.join(target_nodes)}")
            for name in target_nodes:
                # compare non-namespaced container name
                if name not in local_nodes:
                    warning(f"Node '{name}' not found in nodes/ — skipping")
                # compare namespaced container name because taken from Incus
                elif f"{self.config['name']}-{name}" in running_nodes:
                    to_stop.append(name)
                else:
                    info(f"Node '{name}' already stopped")
        else:
            # Stop all running local nodes
            to_stop.extend([f"{self.config['name']}-{n}" for n in local_nodes
                            if f"{self.config['name']}-{n}" in running_nodes])

    def _process_to_stop(self, suspend_req, running_nodes, stop_all, to_stop):
        if suspend_req:
            required_nodes = self.config.get("requires_nodes", [])
            for name in required_nodes:
                if name not in running_nodes:
                    continue  # already stopped
                if not stop_all:
                    # Check if pinned
                    pin_result = run(
                        ["incus", "config", "get", name, "user.pinned"],
                        silent=True, check=False
                    )
                    if pin_result.returncode == 0 and pin_result.stdout.strip() == "true":
                        info(f"Skipping {name}: user.pinned=true")
                        continue
                    # Future: refcount check via user.required_by
                to_stop.append(name)

    def down(self, only=None, suspend_required=False, force_stop_all=False, dry_run=False):
        """
        down: bring down the lab, stop Incus containers
        """
        # Get current container states
        result = run(["incus", "list", "--format=json"], silent=True)
        containers = json.loads(result.stdout)
        running_names = {c["name"] for c in containers if c["status"] == "Running"}

        # Determine which local nodes to stop
        local_node_dirs = [d.name for d in self.nodes_dir.iterdir() if d.is_dir()]
        local_to_stop = []

        if only and (force_stop_all or suspend_required):
            error("Cannot use '--force-stop-all' and/or '--suspend-required' with '--only'")
            return
        self._process_only_flag(only, local_node_dirs, running_names, local_to_stop)

        # Determine required nodes to suspend
        required_to_suspend = []
        self._process_to_stop(suspend_required, running_names, force_stop_all, required_to_suspend)

        # Build actions
        actions = []

        # Stop local nodes
        for name in local_to_stop:
            actions.append({
                "desc": f"Stop local node: {name}",
                "func": run,
                "args": (["incus", "stop", f"{self.config['name']}-{name}"],),
                "kwargs": {"check": True}
            })

        # Suspend required nodes
        for name in required_to_suspend:
            actions.append({
                "desc": f"Suspend required node: {name}",
                "func": run,
                "args": (["incus", "stop", name],),
                "kwargs": {"check": True}
            })

        # Log event
        def log_down():
            self._log_event(
                "down",
                nodes_stopped=local_to_stop,
                requires_suspended=required_to_suspend,
                filtered=only
            )

        if actions:
            actions.append({
                "desc": "Log down event",
                "func": log_down
            })

        self._describe_and_apply(actions, dry_run)

    def add_node(self, name: str, template: str | None = None, dry_run: bool = False):
        """
        add_node: adds a new node into the lab
        """
        # Resolve template
        effective_template = template or self.config["template"]
        container_name = f"{self.config['name']}-{name}"
        info(f"Using scoped name: {container_name}")

        # Validate upfront
        if not container_exists(effective_template):
            raise RuntimeError(f"Template '{effective_template}' not found")
        if container_exists(container_name):
            raise RuntimeError(f"Container '{container_name}' already exists")

        node_dir = self.nodes_dir / name
        mount_point = self.config["node_mount"]["mount_point"]
        shared_mp = self.config["shared_storage"]["mount_point"]

        actions = []

        # 1. Create container
        actions.append({
            "desc": f"Create container '{container_name}' from '{effective_template}'",
            "func": run,
            "args": (["incus", "copy", effective_template, container_name],),
            "kwargs": {"check": True}
        })

        # 1a. Create container
        actions.append({
            "desc": f"Unset inherited template marker on '{container_name}'",
            "func": run,
            "args": (["incus", "config", "unset", container_name, "user.template"],),
            "kwargs": {"check": True}
        })

        # 2. Create node directory
        actions.append({
            "desc": f"Create directory {node_dir}",
            "func": lambda path: path.mkdir(exist_ok=True),
            "args": (node_dir,)
        })

        # 3. Write manifest.yaml
        def write_manifest():
            (node_dir / "manifest.yaml").write_text(f"""name: {name}
    purpose: >-
    Replace with short description
    role: unknown
    tags: []
    environment: development
    owner: {self.config['user']}
    lifecycle: experimental
    created_via: labkit node add
    dependencies: []
    notes: |
    Add usage notes, gotchas, maintenance tips here.
    """)

        actions.append({
            "desc": f"Generate {node_dir}/manifest.yaml",
            "func": write_manifest
        })

        # 4. Write README.md
        def write_readme():
            (node_dir / "README.md").write_text(
                f"# {name}\n\n> Update this with purpose and usage\n")

        actions.append({
            "desc": f"Generate {node_dir}/README.md",
            "func": write_readme
        })

        # 5. Mount node dir
        actions.append({
            "desc": f"Mount {node_dir} → {name}:{mount_point}",
            "func": run,
            "args": ([
                "incus", "config", "device", "add",
                container_name, "lab-node", "disk", "shift=true",
                f"path={mount_point}",
                f"source={node_dir}"
            ],),
            "kwargs": {"check": True}
        })

        # 6. Mount shared storage (if enabled)
        if self.config["shared_storage"].get("enabled", True):
            actions.append({
                "desc": f"Mount {self.shared_dir} → {name}:{shared_mp}",
                "func": run,
                "args": ([
                    "incus", "config", "device", "add",
                    container_name, "lab-shared", "disk", "shift=true",
                    f"path={shared_mp}",
                    f"source={self.shared_dir}"
                ],),
                "kwargs": {"check": True}
            })

        # 7. Set labels
        actions.append({
            "desc": f"Set labels on {container_name}",
            "func": run,
            "args": ([
                "incus", "config", "set", container_name,
                f"user.lab={self.config['name']}",
                "user.managed-by=labkit"
            ],),
            "kwargs": {"check": True}
        })

        # 8. Git commit
        def git_commit():
            subprocess.run(["git", "add", "."], cwd=self.root, check=False)
            env = os.environ.copy()
            env.setdefault("GIT_AUTHOR_NAME", "labkit")
            env.setdefault("GIT_COMMITTER_NAME", "labkit")
            env.setdefault("GIT_AUTHOR_EMAIL", "labkit@localhost")
            env.setdefault("GIT_COMMITTER_EMAIL", "labkit@localhost")
            subprocess.run([
                "git", "commit", "-m", f"labkit: added node {name}"
            ], cwd=self.root, env=env, check=False)  # ignore no-changes

        actions.append({
            "desc": "Commit node metadata to Git",
            "func": git_commit
        })

        # Execute plan
        self._describe_and_apply(actions, dry_run)

    def remove_node(self, name: str, force: bool = False, dry_run: bool = False):
        """
        remove_node: removes a node from the lab
        """
        container_name = f"{self.config['name']}-{name}"
        state = self.get_container_state(container_name)
        if not state:
            warning(f"Container '{container_name}' not found")
            return

        if state == "Running" and not force:
            warning(f"'{container_name}' is running. Use --force to stop and delete.")
            return

        actions = []

        # 1. Stop container
        if state == "Running":
            actions.append({
                "desc": f"Stop container: {container_name}",
                "func": run,
                "args": (["incus", "stop", container_name],),
                "kwargs": {"check": True}
            })

        # 2. Delete container
        actions.append({
            "desc": f"Delete container: {container_name}",
            "func": run,
            "args": (["incus", "delete", container_name],),
            "kwargs": {"check": True}
        })

        # Note: We don't delete nodes/<name>/ — keep docs/history
        actions.append({
            "desc": f"Preserve documentation in {self.nodes_dir}/{name}",
            "func": lambda: None  # Just a message
        })

        # 3. Git commit
        def git_commit():
            subprocess.run(["git", "add", "."], cwd=self.root, check=False)
            env = os.environ.copy()
            env.setdefault("GIT_AUTHOR_NAME", "labkit")
            env.setdefault("GIT_COMMITTER_NAME", "labkit")
            env.setdefault("GIT_AUTHOR_EMAIL", "labkit@localhost")
            subprocess.run([
                "git", "commit", "-m", f"labkit: removed node {name}"
            ], cwd=self.root, env=env, check=False)

        actions.append({
            "desc": "Commit removal to Git",
            "func": git_commit
        })

        # Execute plan
        self._describe_and_apply(actions, dry_run)

    def get_node_count(self):
        """
        get_node_count: get node count inside the homelab
        """
        if not self.nodes_dir.exists():
            return 0
        return len([d for d in self.nodes_dir.iterdir() if d.is_dir()])

    def save_config(self):
        """
        save_config: save current config back to lab.yaml
        """
        data = {
            "name": self.config["name"],
            "template": self.config["template"],
            "user": self.config["user"],
            "managed_by": self.config["managed_by"]
        }
        if "requires_nodes" in self.config and self.config["requires_nodes"]:
            data["requires_nodes"] = self.config["requires_nodes"]
        (self.root / "lab.yaml").write_text(
            yaml.dump(data, indent=2, default_flow_style=False)
        )

    def get_container_state(self, name: str) -> str | None:
        """
        get_container_state: return container status: 'Running', 'Stopped', 
        or None if not found
        """
        container_name = f"{self.config['name']}-{name}"
        result = run(["incus", "list", container_name, "--format=json"], silent=True, check=False)
        if result.returncode != 0:
            return None
        try:
            data = json.loads(result.stdout)
            for c in data:
                if c["name"] == container_name:
                    return c["status"]
            return None
        except Exception as e:
            raise RuntimeError(f"Failed to get container state: {e}") from e

def list_templates():
    """
    list_templates: lists all available templates
    """
    result = run(["incus", "list", "--format=json"], silent=True)
    containers = json.loads(result.stdout)
    templates = [c for c in containers if c["config"].get("user.template") == "true"]
    for c in templates:
        print(f"{c['name']}: {c.get('description', 'No description')}")
