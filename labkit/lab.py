"""
lab.py: module that serve homelab management using abstracted backends
"""
import json
import getpass
import os
from pathlib import Path
import subprocess
from datetime import datetime
import yaml
from .config import LabConfig
from .utils import container_exists, run, info, success, error, warning
from .models import RequiredNode, NodeType
from .backends.base import NodeBackend
from .backends.incus import IncusNodeBackend
from .backends.docker import DockerNodeBackend
from .backends.qemu import QemuNodeBackend

class Lab:
    """
    Lab: class that encapsulates both data and mechanism for managing homelabs
    """
    def __init__(self, root: Path, backend: str = "incus"):
        self.root = root.absolute()
        self.config_path = self.root / "lab.yaml"
        self.config = LabConfig(self.config_path).load()
        self.nodes_dir = self.root / "nodes"
        self.shared_dir = self.root / "shared"
        self.dry_run = False
        self.backend_type = backend
        self.backend = self._initialize_backend(backend)

    def _initialize_backend(self, backend_type: str) -> NodeBackend:
        """Initialize the appropriate backend based on type"""
        if backend_type == "incus":
            return IncusNodeBackend(self.config["name"])
        elif backend_type == "docker":
            return DockerNodeBackend(self.config["name"])
        elif backend_type == "qemu":
            return QemuNodeBackend(self.config["name"])
        else:
            raise ValueError(f"Unsupported backend type: {backend_type}")

    def _describe_and_apply(self, actions, dry_run=False):
        """
        _describe_and_apply: show all planned actions, then execute if not dry_run.
        """
        if not actions:
            info("Nothing to do.")
            return

        info("Planned actions:")
        for act in actions:
            print(f"  {act['desc']}")

        if dry_run:
            info("DRY RUN: No changes applied")
            return

        # Apply
        for act in actions:
            try:
                act['func'](*act.get('args', ''), **act.get('kwargs', {}))
            except Exception as e:
                error(f"Failed to execute: {act['desc']} → {e}")
                raise

        success("All actions completed")

    def _log_event(self, action: str, **details):
        """
        _log_event: logs event triggered by homelab management ops
        """
        log_dir = self.root / "logs"
        log_dir.mkdir(exist_ok=True)
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
        log_file = log_dir / f"{timestamp}-{action}.txt"

        data = {
            "action": action,
            "user": getpass.getuser(),
            "timestamp": timestamp,
            "lab": self.config["name"],
            **details
        }

        lines = [f"{k.upper()}: {v}" for k, v in data.items()]
        log_file.write_text("\n".join(lines) + "\n")

    @classmethod
    def init(cls, path: Path):
        """
        init: initialize a new lab from inside the target directory
        """
        path.mkdir(exist_ok=True)
        lab = cls(path)
        lab.nodes_dir.mkdir(exist_ok=True)
        lab.shared_dir.mkdir(exist_ok=True)

        # Create git repo
        if not (path / ".git").exists():
            subprocess.run(["git", "init"], cwd=path, text=True, check=True)
            subprocess.run(["git", "add", "."], cwd=path, text=True, check=True)
            subprocess.run(["git", "commit", "-m", "labkit: initial commit"],
                           cwd=path, input="init", text=True, check=True)

        # Create README
        readme = path / "README.md"
        if not readme.exists():
            readme.write_text(f"# {lab.config['name']}\n\nGenerated by labkit.\n")

        success(f"Lab initialized at {path}")
        info("Next: labkit node add <name>")
        return lab

    def add_requirement(self, node_names, dry_run=False):
        """
        add_requirement: adds external node as requirement without including
        the node into the lab
        """
        lab_name = self.config["name"]
        requires = set(self.config.get("requires_nodes", []))

        actions = []
        needs_save = False  # ← Track if we need to save lab.yaml

        for name in node_names:
            if not container_exists(name):
                warning(f"Container '{name}' does not exist")
                continue

            if name not in requires:
                requires.add(name)
                needs_save = True  # ← Mark for save later

                def update_required_by(container_name):
                    result = run(
                        ["incus", "config", "get", container_name, "user.required_by"],
                        silent=True, check=False
                    )
                    current = set()
                    if result.returncode == 0 and result.stdout.strip():
                        current = set(result.stdout.strip().split(","))
                    if lab_name not in current:
                        current.add(lab_name)
                        new_val = ",".join(sorted(current))
                        run([
                            "incus", "config", "set", container_name,
                            f"user.required_by={new_val}"
                        ], check=True)

                actions.append({
                    "desc": f"Add '{lab_name}' to {name}.user.required_by",
                    "func": update_required_by,
                    "args": (name,)
                })

        # Save config if any new requirements were added
        if needs_save:
            def save_lab_config():
                self.config["requires_nodes"] = sorted(requires)
                self.save_config()

            actions.append({
                "desc": "Save updated lab.yaml",
                "func": save_lab_config,
            })

        self._describe_and_apply(actions, dry_run)

    def remove_requirement(self, node_names, dry_run=False):
        """
        remove_requirement: removes included external node from requirement
        """
        lab_name = self.config["name"]
        requires = set(self.config.get("requires_nodes", []))
        original_count = len(requires)

        actions = []
        needs_save = False  # ← Will set to True if we remove anything

        for name in node_names:
            if name in requires:
                requires.discard(name)
                needs_save = True  # ← Mark for save

                def update_on_node(container_name):
                    result = run(
                        ["incus", "config", "get", container_name, "user.required_by"],
                        silent=True, check=False
                    )
                    if result.returncode != 0:
                        return
                    current = set(result.stdout.strip().split(",")) \
                        if result.stdout.strip() else set()
                    if lab_name in current:
                        current.remove(lab_name)
                        if current:
                            new_val = ",".join(sorted(current))
                            run([
                                "incus", "config", "set", container_name,
                                f"user.required_by={new_val}"
                            ], check=True)
                        else:
                            run(["incus", "config", "unset", container_name, "user.required_by"],
                                check=True)

                actions.append({
                    "desc": f"Remove '{lab_name}' from {name}.user.required_by",
                    "func": update_on_node,
                    "args": (name,)
                })

        # Save config only if we removed something
        if needs_save and len(requires) != original_count:
            def save_lab_config():
                self.config["requires_nodes"] = sorted(requires)
                self.save_config()

            actions.append({
                "desc": "Save updated lab.yaml",
                "func": save_lab_config
            })

        self._describe_and_apply(actions, dry_run)

    def up(self, only=None, include_deps=True, dry_run=False):
        """
        up: bring up the lab, starting nodes via backend
        """
        # Parse --only into list
        target_nodes = []
        if only:
            target_nodes = [n.strip() for n in only.split(",") if n.strip()]
            info(f"Target nodes: {', '.join(target_nodes)}")

        # Get current node states via backend
        local_running_names = set(self.backend.list_active())

        # For dependencies, we still need to check with the original system (Incus)
        # In a full implementation, dependencies would also use the backend abstraction
        if self.backend_type == "incus":
            result = run(["incus", "list", "--format=json"], silent=True)
            containers = json.loads(result.stdout)
            running_names = {c["name"] for c in containers if c["status"] == "Running"}
        else:
            # For other backends, we might need different logic
            running_names = local_running_names

        # Determine which local nodes to start
        local_node_dirs = [d.name for d in self.nodes_dir.iterdir() if d.is_dir()]
        local_to_start = []

        if only:
            for name in target_nodes:
                if name not in local_node_dirs:
                    warning(f"Node '{name}' not found in nodes/ — skipping")
                else:
                    # local_running_names contains logical names from backend
                    scoped_name = f"{self.config['name']}-{name}"
                    if scoped_name not in local_running_names:
                        local_to_start.append(name)
        else:
            # Start all local nodes that aren't running
            for node_name in local_node_dirs:
                # local_running_names contains logical names from backend
                scoped_name = f"{self.config['name']}-{node_name}" 
                if scoped_name not in local_running_names:
                    local_to_start.append(node_name)

        # Determine required nodes to start (for now, only support Incus for dependencies)
        required_to_start = []
        if include_deps and self.backend_type == "incus":
            required_nodes = self.config.get("requires_nodes", [])
            required_to_start = [n for n in required_nodes if n not in running_names]

        # Build actions
        actions = []

        # Start required nodes first (only for Incus for now)
        for name in required_to_start:
            actions.append({
                "desc": f"Start required node: {name}",
                "func": run,
                "args": (["incus", "start", name],),
                "kwargs": {"check": True}
            })

        # Start local nodes via backend
        for name in local_to_start:
            actions.append({
                "desc": f"Start local node: {name}",
                "func": self.backend.start,
                "args": (name,),
                "kwargs": {}
            })

        # Log event
        def log_up():
            self._log_event(
                "up",
                nodes_started=local_to_start,
                requires_started=required_to_start,
                filtered=only
            )

        if actions:
            actions.append({
                "desc": "Log up event",
                "func": log_up
            })

        self._describe_and_apply(actions, dry_run)

    def _process_only_flag(self, target, local_nodes, running_nodes, to_stop):
        if target:
            target_nodes = [n.strip() for n in target.split(",") if n.strip()]
            info(f"Target nodes: {', '.join(target_nodes)}")
            for name in target_nodes:
                # compare non-namespaced container name
                if name not in local_nodes:
                    warning(f"Node '{name}' not found in nodes/ — skipping")
                else:
                    # running_nodes contains logical names from backend
                    if name in running_nodes:
                        to_stop.append(name)
                    else:
                        info(f"Node '{name}' already stopped")
        else:
            # Stop all running local nodes
            for node_name in local_nodes:
                # running_nodes contains logical names from backend
                if node_name in running_nodes:
                    to_stop.append(node_name)

    def _process_to_stop(self, suspend_req, running_nodes, stop_all, to_stop):
        if suspend_req:
            required_nodes = self.config.get("requires_nodes", [])
            for name in required_nodes:
                if name not in running_nodes:
                    continue  # already stopped
                if not stop_all and self.backend_type == "incus":
                    # Check if pinned (only for Incus for now)
                    pin_result = run(
                        ["incus", "config", "get", name, "user.pinned"],
                        silent=True, check=False
                    )
                    if pin_result.returncode == 0 and pin_result.stdout.strip() == "true":
                        info(f"Skipping {name}: user.pinned=true")
                        continue
                    # Future: refcount check via user.required_by
                to_stop.append(name)

    def down(self, only=None, suspend_required=False, force_stop_all=False, dry_run=False):
        """
        down: bring down the lab, stop nodes via backend
        """
        # Get current node states via backend
        local_running_names = set(self.backend.list_active())

        # For dependencies, we still need to check with the original system (Incus)
        # In a full implementation, dependencies would also use the backend abstraction
        if self.backend_type == "incus":
            result = run(["incus", "list", "--format=json"], silent=True)
            containers = json.loads(result.stdout)
            running_names = {c["name"] for c in containers if c["status"] == "Running"}
        else:
            # For other backends, we might need different logic
            running_names = local_running_names

        # Determine which local nodes to stop
        local_node_dirs = [d.name for d in self.nodes_dir.iterdir() if d.is_dir()]
        local_to_stop = []

        if only and (force_stop_all or suspend_required):
            error("Cannot use '--force-stop-all' and/or '--suspend-required' with '--only'")
            return
        self._process_only_flag(only, local_node_dirs, local_running_names, local_to_stop)

        # Determine required nodes to suspend (for now, only support Incus for dependencies)
        required_to_suspend = []
        if suspend_required and self.backend_type == "incus":
            self._process_to_stop(suspend_required, running_names, force_stop_all, required_to_suspend)

        # Build actions
        actions = []

        # Stop local nodes via backend
        for name in local_to_stop:
            actions.append({
                "desc": f"Stop local node: {name}",
                "func": self.backend.stop,
                "args": (name,),
                "kwargs": {}
            })

        # Suspend required nodes (only for Incus for now)
        for name in required_to_suspend:
            actions.append({
                "desc": f"Suspend required node: {name}",
                "func": run,
                "args": (["incus", "stop", name],),
                "kwargs": {"check": True}
            })

        # Log event
        def log_down():
            self._log_event(
                "down",
                nodes_stopped=local_to_stop,
                requires_suspended=required_to_suspend,
                filtered=only
            )

        if actions:
            actions.append({
                "desc": "Log down event",
                "func": log_down
            })

        self._describe_and_apply(actions, dry_run)

    def add_node(self, name: str, template: str | None = None, node_type: NodeType = NodeType.CONTAINER, dry_run: bool = False):
        """
        add_node: adds a new node into the lab
        """
        # Resolve template based on node type
        if template:
            effective_template = template
        elif node_type == NodeType.VM:
            effective_template = self.config.get("vm_template", self.config["template"])
        else:
            effective_template = self.config["template"]

        node_name = f"{self.config['name']}-{name}"
        info(f"Using scoped name: {node_name}")

        # Validate upfront using backend
        if not self.backend.exists(name):
            # Create RequiredNode specification
            node_spec = RequiredNode(
                name=name,
                node_type=node_type,
                image=effective_template,
                cpus=1,  # Default CPU count
                memory="512MB",  # Default memory
                disk="4GiB",  # Default disk
                config={
                    "user.lab": self.config["name"],
                    "user.managed-by": "labkit"
                }
            )

            node_dir = self.nodes_dir / name
            mount_point = self.config["node_mount"]["mount_point"]
            shared_mp = self.config["shared_storage"]["mount_point"]

            actions = []

            # 1. Create node via backend
            actions.append({
                "desc": f"Create {node_type.value} '{node_name}' from '{effective_template}'",
                "func": self.backend.provision,
                "args": (node_spec,)
            })

            # 2. Create node directory
            actions.append({
                "desc": f"Create directory {node_dir}",
                "func": lambda path: path.mkdir(exist_ok=True),
                "args": (node_dir,)
            })

            # 3. Write manifest.yaml
            def write_manifest():
                (node_dir / "manifest.yaml").write_text(f"""name: {name}
    purpose: >-
    Replace with short description
    role: unknown
    tags: []
    environment: development
    owner: {self.config['user']}
    lifecycle: experimental
    created_via: labkit node add
    dependencies: []
    notes: |
    Add usage notes, gotchas, maintenance tips here.
    """)

            actions.append({
                "desc": f"Generate {node_dir}/manifest.yaml",
                "func": write_manifest
            })

            # 4. Write README.md
            def write_readme():
                (node_dir / "README.md").write_text(
                    f"# {name}\n\n> Update this with purpose and usage\n")

            actions.append({
                "desc": f"Generate {node_dir}/README.md",
                "func": write_readme
            })

            # 5. Mount node dir using backend
            actions.append({
                "desc": f"Mount {node_dir} → {name}:{mount_point}",
                "func": self.backend.mount_volume,
                "args": (name, str(node_dir), mount_point)
            })

            # 6. Mount shared storage (if enabled)
            if self.config["shared_storage"].get("enabled", True):
                actions.append({
                    "desc": f"Mount {self.shared_dir} → {name}:{shared_mp}",
                    "func": self.backend.mount_volume,
                    "args": (name, str(self.shared_dir), shared_mp)
                })

            # 7. Set metadata using backend
            actions.append({
                "desc": f"Set metadata on {node_name}",
                "func": self.backend.set_metadata,
                "args": (name, "lab", self.config["name"])
            })

            actions.append({
                "desc": f"Set managed-by metadata on {node_name}",
                "func": self.backend.set_metadata,
                "args": (name, "managed-by", "labkit")
            })

            # 8. Git commit
            def git_commit():
                subprocess.run(["git", "add", "."], cwd=self.root, check=False)
                env = os.environ.copy()
                env.setdefault("GIT_AUTHOR_NAME", "labkit")
                env.setdefault("GIT_COMMITTER_NAME", "labkit")
                env.setdefault("GIT_AUTHOR_EMAIL", "labkit@localhost")
                env.setdefault("GIT_COMMITTER_EMAIL", "labkit@localhost")
                subprocess.run([
                    "git", "commit", "-m", f"labkit: added node {name}"
                ], cwd=self.root, env=env, check=False)  # ignore no-changes

            actions.append({
                "desc": "Commit node metadata to Git",
                "func": git_commit
            })

            # Execute plan
            self._describe_and_apply(actions, dry_run)
        else:
            raise RuntimeError(f"Node '{node_name}' already exists")

    def remove_node(self, name: str, force: bool = False, dry_run: bool = False):
        """
        remove_node: removes a node from the lab
        """
        state = self.backend.get_state(name)
        if not state:
            warning(f"Node '{name}' not found")
            return

        if state == "Running" and not force:
            warning(f"'{name}' is running. Use --force to stop and delete.")
            return

        actions = []

        # 1. Stop node
        if state == "Running":
            actions.append({
                "desc": f"Stop node: {name}",
                "func": self.backend.stop,
                "args": (name,),
                "kwargs": {}
            })

        # 2. Delete node
        actions.append({
            "desc": f"Delete node: {name}",
            "func": self.backend.remove,
            "args": (name,),
            "kwargs": {}
        })

        # Note: We don't delete nodes/<name>/ — keep docs/history
        actions.append({
            "desc": f"Preserve documentation in {self.nodes_dir}/{name}",
            "func": lambda: None  # Just a message
        })

        # 3. Git commit
        def git_commit():
            subprocess.run(["git", "add", "."], cwd=self.root, check=False)
            env = os.environ.copy()
            env.setdefault("GIT_AUTHOR_NAME", "labkit")
            env.setdefault("GIT_COMMITTER_NAME", "labkit")
            env.setdefault("GIT_AUTHOR_EMAIL", "labkit@localhost")
            subprocess.run([
                "git", "commit", "-m", f"labkit: removed node {name}"
            ], cwd=self.root, env=env, check=False)

        actions.append({
            "desc": "Commit removal to Git",
            "func": git_commit
        })

        # Execute plan
        self._describe_and_apply(actions, dry_run)

    def get_node_count(self):
        """
        get_node_count: get node count inside the homelab
        """
        if not self.nodes_dir.exists():
            return 0
        return len([d for d in self.nodes_dir.iterdir() if d.is_dir()])

    def save_config(self):
        """
        save_config: save current config back to lab.yaml
        """
        data = {
            "name": self.config["name"],
            "template": self.config["template"],
            "user": self.config["user"],
            "managed_by": self.config["managed_by"]
        }
        if "requires_nodes" in self.config and self.config["requires_nodes"]:
            data["requires_nodes"] = self.config["requires_nodes"]
        (self.root / "lab.yaml").write_text(
            yaml.dump(data, indent=2, default_flow_style=False)
        )

    def get_node_state(self, node_name: str) -> str | None:
        """
        get_node_state: return node status: 'Running', 'Stopped',
        or None if not found
        """
        return self.backend.get_state(node_name)

def list_templates():
    """
    list_templates: lists all available templates
    """
    result = run(["incus", "list", "--format=json"], silent=True)
    containers = json.loads(result.stdout)
    templates = [c for c in containers if c["config"].get("user.template") == "true"]
    for c in templates:
        print(f"{c['name']}: {c.get('description', 'No description')}")
